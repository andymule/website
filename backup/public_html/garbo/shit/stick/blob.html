<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - cube</title>
		<meta charset="utf-8">
		<!-- <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/> -->
		<meta name="viewport" content="width=device-width, initial-scale=0.5, user-scalable=no"/>
		<style type="text/css">
			body {
				font-family: Monospace;
				background-color: #101010;
				margin: 0px;
				overflow: hidden;
				
				canvas { -webkit-transform: scale3d(2, 2, 0) translate3d(200px, 110px, 0); }
			}
		</style>
	</head>
	
	<body>

		<script type="text/javascript" src="build/Three.js"></script>

		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>
		

		<script type="text/javascript">

			var container, stats;

			var camera, scene, renderer;
			var mouseHeld = false;

			var cube, plane, line;//, sphere;
			var light1, light2;
			var particle1, particle2;
			var spheres = [];
			//var lines   = [];
			var radius = 4;
			var NUMBERSPHERES = 30;
			var G = .0004;
			var ENERGYLOSS = .00;
			var FLASHCOUNTER = 10;
			var ACCELLERATION = .00007;
			var MAXSPEED	  = .15;
			var counter      = 0;
			var materials  = [];
			var materials2 = [];

			var targetRotation = 0;
			var targetRotationY = 0;
			var targetRotationOnMouseDown = 0;
			var targetRotationOnMouseDownY = 0;
			var targetMoveX = 0;
			var targetMoveY = 0;
			var targetMoveXOnMouse = 0;
			var targetMoveYOnMouse = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;
			var mouseY = 0;
			var mouseYOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();		

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = 'Drag to spin the cube';
				container.appendChild( info );

				camera = new THREE.Camera( 70, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.x = 0;
				camera.position.y = 140;
				camera.position.z = 500;
				camera.target.position.y = camera.position.y;

				scene = new THREE.Scene();
				
				/*
				scene.addLight( new THREE.AmbientLight( 0xF0F0F0 ) );

				light1 = new THREE.PointLight( 0xf0D040, 1, 50 );
				scene.addLight( light1 );
				*/
				
/*
				scene.addLight( new THREE.AmbientLight( 0x505050 ) );
				light1 = new THREE.PointLight (0xDFDF90,1,500);
				light1.position.x = 150;
				light1.position.y = 250;
				light1.position.z = 150;
				scene.addLight(light1); 	
*/	
						

				//light2 = new THREE.PointLight( 0x0040Cf, -800, -800 );
				//scene.addLight( light2 );
				
				/*
				var PI2 = Math.PI * 2;
				var program = function ( context ) {
					context.beginPath();
					context.arc( 0, 0, 1, 0, PI2, true );
					context.closePath();
					context.fill();
				}
				
				particle1 = new THREE.Particle( new THREE.ParticleCanvasMaterial( { color: Math.random() * 0xFFFFFF, program: program } ) );
				particle1.scale.x = particle1.scale.y = particle1.scale.z = 0.5;
				scene.addObject( particle1 ); */

				// Cube
				for ( var i = 0; i < 6; i ++ ) {
					var temp;
					materials.push( [ new THREE.MeshBasicMaterial( { color: temp = (Math.random() * 0xFFFFFF) } ) ] );
					materials2.push( [ new THREE.MeshBasicMaterial( { color: temp } ) ] );
				}
				cube = new THREE.Mesh( new THREE.CubeGeometry( 100, 100, 100, 1, 1, 1, materials ), new THREE.MeshFaceMaterial() );
				cube.position.y = 300;
				cube.position.z = -51;
				cube.overdraw = false;
				//scene.addObject( cube );

				// Plane
				var text = THREE.ImageUtils.loadTexture( "wood8.jpg" );
				var mat  = new THREE.MeshLambertMaterial( { map: text } );
				plane = new THREE.Mesh( new THREE.PlaneGeometry( 600, 200 ), mat );
				plane.rotation.x = - 90 * ( Math.PI / 180 );
				plane.position.y = 0;
				plane.overdraw = false;
				
				scene.addObject( plane );
				
				/*
				var plane2 = new THREE.Mesh( new THREE.PlaneGeometry( 8000, 8000 ), new THREE.MeshBasicMaterial( { color: 0x101010, opacity: .5 } ) );
				//plane.position.x = 0;
				plane2.position.y = -2000;
				plane.rotation.x = - 90 * ( Math.PI / 180 );
				plane2.overdraw = true;
				scene.addObject( plane2 );
				*/
				
				//createSphere(50, new THREE.Vector3(0, 0, 0));
				var geometry = new THREE.Geometry();
				var i;
				for (i=0; i<NUMBERSPHERES; i=i+1) {
					var sphere = new THREE.Mesh( new THREE.SphereGeometry( radius, radius, radius ), new THREE.MeshLambertMaterial( { color: (Math.random() * 0xFFFFFF)}));//, shading: THREE.FlatShading } ) );
	                sphere.color    = Math.random() * 0xFFFFFF;
			  sphere.position = new THREE.Vector3(40*i+50, 40*i+50, 0);
	                sphere.overdraw = false;
	                scene.addObject(sphere);
	               /* spheres[i] = new THREE.Mesh( new THREE.SphereGeometry( radius, radius, radius ), new THREE.MeshLambertMaterial( { color: Math.random() * 0xFFFFFF} ) );
	                spheres[i].position = new THREE.Vector3(0, 20*i-80, 0);
	                spheres[i].overdraw = true;
	                scene.addObject(spheres[i]); */
	                sphere.ax = 0.0;
	                sphere.ay = -G;
	                sphere.az = 0.0;
	                sphere.vx = 0.0;
	                sphere.vy = 0.0;
	                sphere.vz = 0.0;
	                spheres.push(sphere);
	                geometry.vertices.push(new THREE.Vertex( sphere.position ));
	            }
	            geometry.vertices.push(new THREE.Vertex(spheres[NUMBERSPHERES-1].position));
	            geometry.vertices.push(new THREE.Vertex(spheres[0].position));
	            
	            line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth: 1.5 } ) );
	             	//lines.push( line );
				//scene.addObject( line );
				

				renderer = new THREE.CanvasRenderer();
				//renderer._microCache = new MicroCache();
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
			}

			function onDocumentMouseDown( event ) {
				mouseHeld = true;
				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationOnMouseDown = targetRotation;
				targetRotationOnMouseDownY = targetRotationY;
			}

			function onDocumentMouseMove( event ) {
				mouseHeld = true;
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfX;

				targetRotation  = targetRotationOnMouseDown  + ( mouseX - mouseXOnMouseDown ) * 0.02;
				targetRotationY = targetRotationOnMouseDownY + ( mouseY - mouseYOnMouseDown ) * 0.02;
			}

			function onDocumentMouseUp( event ) {
				mouseHeld = false;
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {
				mouseHeld = false;
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {
					

					event.preventDefault();
					//f.touches[0].pageX - (window.innerWidth - g.width) * 0.5;

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationOnMouseDown  = targetRotation;
					targetRotationOnMouseDownY = targetRotationY;
					targetMoveXOnMouse = targetMoveX;
					targetMoveYOnMouse = targetMoveY;
				}
				mouseHeld = false;
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {
					mouseHeld = true;
					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
					targetMoveX = targetRotation  = targetRotationOnMouseDown  + ( mouseX - mouseXOnMouseDown ) * 0.05;
					targetMoveY = targetRotationY = targetRotationOnMouseDownY + ( mouseY - mouseYOnMouseDown ) * 0.05;
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}
			
			function physics() {
				for(var i=0; i<NUMBERSPHERES;i++)  {					
					var t = spheres[i];
					if(NUMBERSPHERES==1) {;}					
					else if ((i==0) && (!mouseHeld)) {
						t.ax = (spheres[i+1].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[i+1].position.y-t.position.y)*ACCELLERATION;
						t.ax = (spheres[NUMBERSPHERES-1].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[NUMBERSPHERES-1].position.y-t.position.y)*ACCELLERATION;
					}					
					else if (i==(NUMBERSPHERES-1)) {
						t.ax = (spheres[i-1].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[i-1].position.y-t.position.y)*ACCELLERATION;
						t.ax = (spheres[0].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[0].position.y-t.position.y)*ACCELLERATION;
					}
					else if (i!=0) {
						t.ax = (spheres[i+1].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[i+1].position.y-t.position.y)*ACCELLERATION;
						t.ax = (spheres[i-1].position.x-t.position.x)*ACCELLERATION;
						t.ay = -G+(spheres[i-1].position.y-t.position.y)*ACCELLERATION;
					}
					if (!((i==0) && (mouseHeld))) {
						t.vx += t.ax;
						t.vy += t.ay;
						t.vz += t.az;
					}
					var tempPos = new THREE.Vector3(t.position.x+t.vx,t.position.y+t.vy,t.position.z+t.vz);
					if (tempPos.y<0) {
						tempPos.y = -tempPos.y;
						t.vy = -t.vy*(1-ENERGYLOSS);
						//targetRotation+=(.2*Math.random()-.3);
						//targetRotationY+=(.2*Math.random()-.3);
						// var sides=6;
						// for (var kkk=0; kkk<sides; kkk++) {
							// materials[kkk][0].color.setHex( 0xffffff );							
						// }
						// counter=0;
					} 
					if (tempPos.x+radius>400) {
						tempPos.x = 400-radius;
						t.vx = -t.vx*(1-ENERGYLOSS);
					} 
					if (tempPos.x-radius<-400) {
						tempPos.x = -400+radius;
						t.vx = -t.vx*(1-ENERGYLOSS);
					} 
					//var j;
					spheres[i].position = tempPos;
					for(var j=0; j<NUMBERSPHERES;j++)  {
						var check = spheres[j];
						if (check == t) { //if same ball, go on 
							t.materials[0].color.setHex( 0x50ffff );
							continue;
						}						
						if (checkHit(t,check))  {
							t.materials[0].color.setHex( 0xff0000 );
						    hit(t,check);		
						}				    
					}				
						
					//spheres[i].position.y -= 1;
					//t.position.y -= 1;
					if (t.vx>MAXSPEED)
						t.vx=MAXSPEED;
					if (t.vx<-MAXSPEED)
						t.vx=-MAXSPEED;
					if (t.vy>MAXSPEED)
						t.vy=MAXSPEED;
					if (t.vy<-MAXSPEED)
						t.vy=-MAXSPEED;
				}
			}
			
			function checkHit(t, check)	{
				var distSqr = distance(t,check)*distance(t,check);
				var sqrRadius = radius * radius;
				
				if (distSqr <= sqrRadius){
					return true;
				}		
				return false;
			}
			
			function hit(t, check) {
			    var Del = 2*radius;
			    var DX  = check.position.x-t.position.x;
			    var DVX = check.vx-t.vx;
			    var DY  = check.position.y - t.position.y;
			    var DVY = check.vy - t.vy;
			    var D2  = DX * DX + DY * DY;
			    var mu = 1;//ThingTwo.Mass / ThingOne.Mass
			    var alpha = ((1+0) / (1 + mu) * (DX * DVX + DY * DVY) / D2);
			    t.vx += mu * DX * alpha;
			    t.vy += mu * DY * alpha;
			    check.vx -= DX * alpha;
			    check.vy -= DY * alpha;
			    var DDist = ((Del - ENERGYLOSS) / Math.sqrt(D2) - 1) / (1 + mu);
			    t.position.x -= DX * DDist * mu; t.position.y -= DY * DDist * mu;
			    check.position.x += DX * DDist; check.position.y += DY * DDist;
			    return alpha * (1 + mu);
			}			
			
			function distance(t, check) {
				return Math.sqrt((t.position.x-check.position.x)*(t.position.x-check.position.x)+
								 (t.position.y-check.position.y)*(t.position.y-check.position.y))
			}

			function render() {
				// counter++;
				// if (counter==FLASHCOUNTER) {
						// for (var kkk=0; kkk<6; kkk++) {
							// materials[kkk][0].color.setHex( materials2[kkk][0].color );
							// //materials[kkk][0].color.setHex( 0xffffff );
							// //counter=0;
						// }
				// }
				/*
				var time = new Date().getTime() * 0.001;
				
				particle1.position.x = Math.sin( time * 0.7 ) * 30;
				particle1.position.y = Math.cos( time * 0.5 ) * 40;
				particle1.position.z = Math.cos( time * 0.3 ) * 30;

				light1.position.x = particle1.position.x;
				light1.position.y = particle1.position.y;
				light1.position.z = particle1.position.z;
				*/

				//plane.rotation.z = cube.rotation.y += ( targetRotation - cube.rotation.y ) * 0.05;
				//plane.rotation.x = cube.rotation.z += ( targetRotationY - cube.rotation.z ) * 0.05;
				/*
				var i;
				for(i=0; i<NUMBERSPHERES; i++) {
					spheres[i].position = new THREE.Vector3(mouseX+50-40*i, -mouseY+50-40*i, 150);
					//40*i-130, 40*i+70, 150);
				} */
				var geometry = new THREE.Geometry();
				var selected;
				for(i=0; i<NUMBERSPHERES; i++) {
					if (mouseHeld) {
						spheres[0].position = new THREE.Vector3(mouseX, -mouseY, 0);
						//40*i-130, 40*i+70, 150);
					}
						physics();
						geometry.vertices.push(new THREE.Vertex( spheres[i].position ));
				}
				line.geometry = geometry;
				//spheres[0].position = new THREE.Vector3(mouseX, -mouseY, 0);
				cube.rotation.y += ( targetRotation - cube.rotation.y ) * 0.05;
				cube.rotation.z += ( targetRotationY - cube.rotation.z ) * 0.05;	
							
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>

